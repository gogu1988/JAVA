Hi there, and welcome to this session on
Core Module Patterns. In this session,we'll start with a quick review of the
different elements that we might findinside of core business modules which
will be in the core layer of the fourlayer architecture then we'll begin
looking at the core business modulepatterns which are patterns that start
in the core layer but may involve otherlayers as well so we'll look at the core
entity pattern we'll look at theexternal core into tea service patterns
and there are several of these typeswe'll look at the base external core
service pattern and then there arevariations so we'll look at the local
replica and the synchronizationvariations and we'll look at the direct
integration variation and a pub/subvariation and then there are also
variations not just in the way weapproach it but sort of how we deal with
the different calls that are made sowe'll look at local caching and lazy
loading variations as well and then toend we'll look at another important
pattern called the transparency servicepattern so a lot of things to review
let's go ahead and get started so as webegin introducing the patterns in the
core business module layer we'll beginto see that there are a number of
typical elements that we find inside ofcore business modules from a UI
perspective we would not expect to seescreens or screen flows in a core module
but we would expect to see web blocksthat might be available to consumers for
example if we wanted to expose a webblock that contained a summary of a
product it could include an image adescription and the price and would
provide a standardized way of reusingthat whole summary from a logic
perspective we would expect to be ableto find all the necessary change
operations for our core entities as wellas other requirements like audit trails
or integration logic so the operationsthat are made available to consumers
could hide any of the side effects orextra logic that would be included from
a data perspectivewe would expect to have core entities
representing our core business conceptsthese entities should be exposed in a
read-only fashion to ensure that thecore module is properly abstracting all
of the change operations that need to bemade available this prevents consumers
from performing transformations on thedata in some sort of uncontrolled way we
also may have a need for asynchronousdata processing this may include data
synchronization or any type of digestinformation that might need
classifications or counts of that datathe idea here is to have the core module
abstract the way the data is handled sothe relevant data is available
immediately to the consumer and theydon't have to know as many of the
details asynchronous programming insideof out systems is either done with
processes or timers so there are acouple choices as to how we would
approach that finally a core module canalso expose different types of roles
these roles may be different than othertypes of roles that could be shared from
maybe a library service those might becompany-wide types of roles in this
particular case for the core modulesthey may be specific to some sort of
feature that's implemented in the moduleso if we have a module that's focused on
products we might have a role likeproduct administrator who would be able
to edit the details of that product andthen that could be used inside of our
logic and inside of our web blocks to goahead and restrict access to certain
types of functionality so now that we'veseen the types of elements that we
expect to find inside of the coremodules let's look at some of the common
patterns in more detail the most commonpattern for a core module is the core
entity pattern it would expose entitiesaround the core concepts like product or
product family it would also expose allthe logic to perform updates on those
entities and any web blocks that mightprovide reusable UI components to
show the data about those entities acore entity should be reusable by one or
more applications if we had a recallprocess a supplier audit and a store
audit process all of them would need toknow information about products so if we
had a product services core entity itcould be exposed as a read-only entity
and we could create a set of actions inlogic that would become the API to
centralize exactly how that entity wouldbe created and updated this pattern is
fairly simple and straightforwardbecause our core service is the system
of record and is storing the data inentities inside of out systems let's
look at another key variation of thiscore entity pattern so if we think of an
example where the system of record is indoubt systems itself but might be an
external ERP system and we wouldimplement an integration service in the
library layer to abstract the externalsystem and get the data into our core
service module in this case there's noentity storing the data in the core
service the core service is justproviding an API that makes the remote
call to the external system whenever thedata is needed this is what we call an
external core entity or the externalcore service pattern often we refer to
this pattern as the ECS pattern becausein this case our core entity although it
has the capabilities and the look of aregular core entity the information is
coming from an external system somethingthat's important is that this
integration service in the library layerthat API must support all the use cases
that the external core service is goingto be able to support so that can be
very important this is such a keyservice that there are actually many
variations of this service in thisparticular case we're seeing an example
where the external system is still thesystem of record and we're not
keeping any data at all this approachcan actually impact the external system
if we're making a large number of callsit can also have performance
implications due to the latency of thecall through the integration service to
the external system and the fact thatevery call needs to go through both sets
of systems and then return to actuallyget the information back the data
retrieval may not actually be optimizedas well so there are some drawbacks to
this and we need to think about how wewould be able to get information from
the external system in a little bit moredetail the external core service has two
main variations that can help us withthe location of the data one is having a
local replica and another is doingsynchronization so if we go ahead and
list the external core service patternhere as a reference then we can go ahead
and look at different variations of thispattern the first variation can be an
improvement over the base patternbecause we're going to use a local
replica of the external core systemsdata in this pattern we'll provide local
entities to this core service to cachethe information from the external
service this will end up looking exactlylike the core entity pattern because
we'll now have some public entities thatwould allow consumers to retrieve the
data this pattern should also have somesort of asynchronous processes to
retrieve data from the external systemsand store it in the entity that is
serving as the local cache now someadvantages of this approach include the
ability of this entity to retrieve dataand also use things like scaffolding and
other accelerators inside of out systemsalso this integration API can be much
simpler because we don't need all usecases to go to the enterprise resource
planning system the external system weonly have to have an API that allows us
to get all of the updates that need thatare needed since
last synchronization has occurred anytype of composition or filtering of data
that might be needed by the consumer canactually be performed using the local
cache of course this approach also endsup having a smaller impact on the
external system since we don't need tomake as many requests to get the data
the second variation is very similar tothe first with the main difference being
that we're going to isolate thesynchronization logic into its own
module having a synchronization moduleas a pattern that we promote not only
because the consumers of the coreservice don't need to consume the
synchronization logic but also we wishto have code independence which allows
us to update either of these sets ofcodes independently this would allow us
to update the synchronization logicwithout impacting the consumers of the
core service and the synchronizationlogic may be orchestrating the
synchronization of several core servicesin which synchronization order is
important because sometimes when we'resynchronizing data from an external
service we may not be able tosynchronize all the data because it's
too much data so if we only need asubset of the data then the
synchronization module can use theintegration service to get the
information it needs from the externalservice and then it can use the core
service to go ahead and update theinformation in the local cache that
synchronization sequence sort of impliesthat we no longer need the reference
from the core service to the integrationservice but we still will have this
direct reference because whenever aconsumer wishes to perform updates we
should first perform the update throughthe integration service on the external
system and then once we know the updatewas successful we can update the local
cache as well the external system isstill the system of record and we try
hard to avoid two-way synchronizationwhenever possible because that can be a
lot more complicated and this means thatthe updates are being done synchronously
while thelarger synchronizations are really being
done asynchronously it also means thatwe may need to deal with the occasion
where someone updates the externalsystem and it didn't originally come
from our core service or any of theother pieces of this architecture
another variation of the external coreservice pattern is one of direct
integration instead of using asynchronization process to retrieve data
at certain times we may want to be ableto immediately react to any change on
the external system in this case we needto provide some sort of API to the
external system so it can notify us whena change occurs then we can use the
normal path to go ahead and get thechanges from the external system this is
basically a kind of subscriptionmechanism this type of pattern leads us
to our final ECS variation whichintroduces an Enterprise Service bus or
an ESB if there's an ESB which isproviding publish and subscription
services and we can adapt the previouspattern to have the core service
actually publish to the bus and theexternal system to be able to observe
for that information from the bus we canalso have the external Service publish
other changes to the bus which wouldthen be subscribed to by the core
services API when we're getting datafrom an external system sometimes
there's too much information eitherbecause we don't have all the attributes
of a particular entity or because wedon't need all the records of a
particular type of data so there arevariations of these patterns that can
help us regulate the amount of data andnot just the timing at which we get it
let's take a look at some of those sothe first is the summary cache only we
would cache only the summary data thatis frequently listed joined or searched
so the full details for a single entrywill be fetched directly whenever
they're needed but the summary data willactually be kept in the cache so we want
to use this again when the wholedatabase or whole set of entities is too
large or too costly to synchronize andthe details are only required for single
entries so we'd actually see the listselect one and then be able to get that
which should be a fairly small call thatcould happen very quickly with the list
actually inside the cache the list canconstantly be refreshed quickly and
we'll be able to see that in the userinterface there's also the lady lazy
loading variation where we try to fetchthe data from the local cache entity if
it's not there then we go and get thesingle entry from the external system we
then cache that record which issometimes referred to as read-through
caching this can be very useful whenagain the whole database is too big or
too costly to synchronize and ourintegrations are only going to get small
sections of the database we do want toavoid this though when we need access to
a list and we need that information upfront the final pattern that we'd like
to discuss is the transparency servicepattern the transparency service pattern
typically provides information that maybe coming from various external systems
for example we may have all of ourenterprise customers in the first ERP
all of our medium-sized customers in oursecond ERP and many of our small
customers in our SAS system in this casethe integration service will decide
which driver to use depending on thetype of customer that is encountered
each driver exposes the exact same APIbut they integrate with their specific
external system the core service canthen use the integration service and
synchronize or cache the data asnecessary we can also simplify this
transparency service when we don't needto perform updates from the core service
in that case the integration serviceisn't even necessary because the
decision for where to retrieve the datacould
be handled by the synchronization or thecore service itself so if we take a look
at that and draw it out we could see aone-way transparency service that is
simplified where the integration serviceis gone we decide that the
synchronization synchronization servicewill talk to the drivers and decide how
to retrieve the information and thenconsumers can get the information they
need from the local cache and in thiscase there won't be any updates coming
through the system to these ERPs becausewe're just reading information so it's
important to see these types ofillustrations because for any of the
patterns that we've talked about or anyof the variations we can make minor
modifications to these patterns to dealwith the instances of given scenarios as
long as we keep the correct level ofabstraction we are trying to reduce the
impact of the different life cycles onthe individual modules and code that are
there if we can manage that complexitythen we can always modify the patterns
to fit the situation as best we can soas a quick review we went over the
elements in the core business modulesand then we looked at some of the
typical patterns we looked at the coreentity pattern and then what happens
when that core entity pattern becomes anexternal core entity and then we get the
external core service patterns we lookedat the base pattern when we have local
replicas and how to do synchronizationas well as how to do direct integration
and pub/sub then we looked at largeinformation scenarios where we could do
a local cache or we could do lazyloading and we ended up by talking about
the transparency service pattern so wecovered an awful lot of complicated
information in this session so hopefullyyou enjoyed the core business patterns
thank you for listening