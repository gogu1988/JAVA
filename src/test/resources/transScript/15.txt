Hi there, and welcome to this session on
Library Module Patterns. In this case,when we use the term library, we're
referring to the library layer of thefour layer canvas so we'll be covering
most common patterns that are used inthe library layer so we'll start by
doing a quick review of the librarymodule elements and the types of
elements that are key to different typesof patterns then we'll jump into looking
at two key library module patterns theextension pattern and the connector
pattern and then we'll talk a little bitabout how when some of these patterns
are being used we have to be carefulabout the granularity of api's that are
created so let's go ahead and getstarted there are a number of different
typical elements that we might findinside of library modules from a logic
perspective we would find normalizedapi's these would map to the external
systems and provide information in a waythat's consumable we also may find
exception handling in which we'd want toavoid different types of error codes so
for example if we have an integration toa web service of an external system
where that system returns some sort ofboolean with an error code we wouldn't
want to propagate the error code to ourconsumers otherwise they have to be
aware of the details of the externalsystem and we want to insulate them from
having to know those types of details sowe can hide those pieces of information
inside of the library module thatperforms the call we can do the test as
to whether it's successful or not andthen throw an exception if necessary
exception handling should be the normalway that these types of things are
handled especially when we use theminside of patterns we could also have
logic inside of a library module thatdeals with single sign-on and different
types of session logic that will help usinteract with the external system but it
will hide how that interaction occursfrom the consumers that are planning on
using those api's from a dataperspective we would expect to find
structuresfor inputs and outputs of the types of
calls that will be made to thosenormalized api's and we also may find
non core entities that aren'tbusiness-related
those types of entities might besomething like points on a map or other
types of information when we'reintegrating with other systems that
don't have directly to do with thebusiness but are still important from
the UI level we may probably find UIwidgets we would not find full screens
but we might get standardized componentslike a calendar or an accordion we also
want to be able to extract and reusethemes layouts and exception flows so
those could be included inside oflibrary modules as well also we may have
roles from a specific domain like acompany's intranet common examples might
be employee or manager and we wouldinclude these in a library module so
that they can be reused across multipleapplications this can help prevent the
creation of similar roles in multipleapplications that would require
administration and changes to all ofthose roles when any any time when a
common role might change so these aresome of the typical elements that we're
going to find in library modules whatare some of the typical types of
patterns a very common library patternis the extension pattern an extension
that was generated by integration studiocan be a wrapper to an external code
library which might be something like adotnet code library to generate a PDF so
here we can see that our wrapper couldgo ahead and contain the logic the
actions and the data that will exposethe code that is inside of the external
library this way things inside of theOutSystems environment can use all of
the things that are coming from theexternal library another type of
extension pattern is a wrapper that willwrap entities from an external database
sowe'll use the integration studio again
to inspect the external database andimport the data structures so they can
be used as entities inside of outsystems entities created in this way can
behave like regular out systems entitiesthey will have any of the actions and
can be used inside of aggregates as wellanother important pattern is the
connector pattern the connector patternis a pattern with two modules an
extension module that can be used toencapsulate an external API and a
wrapper module to expose the normalizedAPI to the consumers here we can see the
extension module for something like aSalesforce connector and here we can see
the module that will be the wrapper thatwe're going to name as far as a is which
would be an integration service so wewant to be able to use these two modules
together and part of being able to dothat would be using the extension to
encapsulate the external API so here wecan see that we're actually able to do a
Salesforce query which is part of theoriginal API and we have all of the
input and output structures that will goto that particular type of API but we
also want to have the wrapper module forconsumers we want to abstract the
details of the external system and makeit easier to use and simpler to
understand so if we need to do somethinglike an account search we don't really
want to call it a Salesforce query wewant to call it an account search so we
begin using naming to match the use caseand the concepts that are important we
can go ahead and handle sessionmanagement so that the interactions with
the external system are hidden but areavailable in a way that's easy to
understand and then we can alsonormalize business concepts so instead
of having something like a return objectwe'll actually have a an account
structure and an opportunity structurewhich might be easier for the business
to understandan important consideration for the
integration services of the connectorpattern is to keep the right level of
granularity of the api's when we'reintegrating with large external systems
for example we might have a very largesi P system if it had hundreds of
babbies that might create hundreds ofapi's and structures inside of our
integration service instead of havingone huge integration service it might
make sense for us to split this largeintegration into a number of smaller
api's and integrations per functionalarea so we could break this into the SI
P financials si pH R and s AP materialsmanagement they would still be talking
to the same external si P system butthis helps balance the granularity and
avoid a single bottleneck that mightaffect too many consumers what we mean
by that is that this integration servicewould have to be used by anyone who
wants access to the large si P systemwe're here by breaking things up people
using the finance components versus theHR components would actually be using
different integration services not onlydoes that help avoid potential
bottlenecks but it could also make thesolution easier to maintain consumers of
the financial api's would not beimpacted by changes or additions to the
HR api so to review here we looked atthe library module elements and how
those elements will show up in differenttypes of library module patterns a key
pattern that we talked about was theextension pattern in the two different
ways the extension pattern can becreated and with yun looked at the
connector pattern and how theintegration services of those connector
patterns might need to be sensitive tothe granularity of the api's that are
created so that's it for the librarymodule patterns thanks for listening