In this lesson, we will lookat the typical elements thatyou'll find inside each layer's Modules. By now, the ArchitectureCanvas is no surprise to you. Let's go over each layer and see thetypical elements that you'll find there. Let's start with the Foundationlayer, where you will have your integrationsand non-functional requirements. The highly-reusableelements are defined in this layer. From a data perspective,you might need structuresfor inputs and outputs to handledata exchanges with external systems. However, you wouldn'texpect to have any coreEntities because this is forintegration and non-business functionalities. In regard to Logic, thislayer provides actions to otherModules in the form of normalized APIs. If you need tocommunicate with external systems,then you will probably also needsome sort of exception handling. This will ensure thaterror codes and exceptionsthat might occur are handled correctly. If you needcustomized authentication flows,such as acentralized single sign-on, thatis also present at the Foundation layer. Session logic might alsobe needed, and the correctplace is also in the bottom layer. Finally, there may beroles.  You could store rolescommon to a particular domain of users. Roles like Manager orEmployee tend to be highly reusable,so it makes sense to also putthose roles in a Foundation Module. Also in the Foundation layer,you may have Modules to definehighly-reusable UI patternsor blocks, like a calendar. Themes, layouts, andexception flows are moreexamples of elements that end upbeing reused across several other Modules. All of this could bereusable, and part of a theme Modulethat you store in the Foundation layer. Now, if we move to the Core layer. Core business concepts appear here. The elements here will be consumedby the Modules from the End-User layer. In terms of data, the corebusiness entities should live here. These Entities shouldbe exposed as read-only,and the logic inside the Modulecontrols manipulation of their data. So, how is datachanged by other Modules?Well, you should expose thechange operations via Server Actions. By doing this, youhave a well-defined API. This makes it easier toset default values as needed,or to perform auditing. You may also haveintegration logic that wraps theintegration services that existbelow, in the foundation layer. Finally, in core Modules youwould also have roles to definethe different types of accesses tothe features available in those Modules. Some of the elements thatmight be part of those coreModules are reusable UI business blocks. These blocks arebusiness-specific and display information the wayyou need it for the specific business. Note that no Screensshould be defined in this layer. With the core Entities, youmay also have asynchronous dataprocessing in case youwant to classify, synchronize,count, or aggregate information. You can use both business processesand timers to perform such tasks. Only one layerremains - the End-User layer. This is where essentially yourScreens and auxiliary elements are defined. From a data perspective, you'd havepotentially different types ofEntities that would help save the UI status,as well as someauxiliary structures if needed. Some business logicmight exist, but theseelements are not reusable and aremeant to support specific use cases and UI. An example would be form validations. You wouldn't want any genericreusable logic in this layer. If that's the case, thenyou should probably extractit and place it inside a core Module. Inside the end-userlayer, you would expectto find very specific role-based UI tosupport the use cases or the processesthat you're trying to make available. Finally, you may needthe business process itself,defined as a workflow. Any processes thathelp support the use casewould be in an end-user Module as well. That's it. Don't miss the next lesson,where we will see the typicalModule elements in a specific scenario. 