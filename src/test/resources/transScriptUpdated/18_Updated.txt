Hi there, and welcome to this session onLocal Storage and Synchronization. In this session we'd like to discuss howmobile applications are allowed to uselocal storage which can help them limitthe number of server-side calls thatneed to be made we also want to discusssynchronizing data if mobileapplications can keep data on the clientside which is the local storage then howoften they synchronize the data can bein a very important part of theapplication and knowing the frequencythe size of the data the number oftransactions and the granularity of thedata that needs to be synchronizedis very important to the overallperformance and the experience thatusers will get so we have a lot to talkabout let's go ahead and get startedthis may look familiarit is the big picture of out systems inan enterprise we can build applicationsor microsites which will be supported byreusable services these reusableservices can be exposed via api's andthey can leverage external capabilitiesthrough integration services theseservices can also implementnon-functional requirements or plug inservices that would allow us to takeadvantage of some of the other mobiledevice features and given thisenvironment let's look at some of thearchitectural best practices for mobileapplications one good practice in mobilearchitecture is to use local storageit's important to understand thedifference between central or serverside storage and local storage that isavailable on the mobile device in thisexample we have some banking coreservices they store information on theserver side and support to differentmobile applications one is for thecompany agents who need to accessaccounts of customers they are managingand the other is a mobile banking app toallow customers to manage their ownaccountseach application will have a coreservice of its own in its own module toimplement all of the client-side logicand entities that would support each ofthese use cases one key aspect of mobileapplication architecture that we want totake advantage of is to use the localstorage effectively we want to optimizethe local storage and the client-sidelogic for each of the end-userapplications because each will have itsown different use cases for instancesince the mobile banking app only dealswith one customer account at a time itcan be optimized to retrieve and storeless data it will require less logicthan the mobile agent app which probablyhas to access and manage multipleaccounts and may have more complicatedlogic optimizing client-side code anddata models is important because theresources can be loaded and cashed intolocal storage for better performance andto support offline use cases storingresources locally requires that we willsynchronize that information with theserver at some point thatsynchronization approach should beoptimized for each specific use casebecause performance is crucial to eachof these mobile applications now we willneed to map server-side static entitiesinto local entities because the localstorage does not contain the concept ofa static entity so we may be able toreduce the overall amount of informationthat we keep in local storage in generalto support the specific applicationsthat are out there so these localentities may end up being a little bitsmaller than their server-sidecounterparts because the server-sidecounterparts may be actually supportingmultiple use cases at the same timeanother good practice that is closelyrelated to using local storage islimiting server-side calls in a mobileapplication we'd like to run as muchlogic as possible on the client-sideserver-side calls will allow us toaccess centrally stored information andperform transactions regarding thatinformation so one of the first thingswe should do is limit server-side callsto online transactions orsynchronizations so our applicationsshould be performing as much of the workas possible on the client side and onlycall the server when those onlinetransactions something like a paymentwould occurwe'd also call the server when we areperforming work that needs the actuallatest information requiring us tosynchronize the data to our local storeddata now we should also avoid makingdirect calls from client logic all theway to back-end systems there areseveral reasons to avoid this from asecurity perspective we don't want toexpose our internal services from ourback-end systems to end-userapplications from a performanceperspective it would also be good tocache some of the backend systeminformation on the server side andoptimize the amount of data that willactually be sent to the app and finallyfrom a maintainability standpoint thecall to the back-end service wouldrequire JavaScript code - from the appand that code can be harder to maintainso we can see that limiting server-sidecalls that can be helpful and we shouldtry to limit this as much as we can toonline transactions and synchronizationswhen we do need synchronizations thereare some other things we should bethinking aboutsynchronization between an app and theserver can be done in many differentways so there's a few basic tips that ithelps to follow some of those revolvearound the frequency and amount of datain the synchronization so first it helpsnot to sync on every screen or onlineevent some applications actually containlogic in the header of every screen torefresh local data from the serversimilarly some apps will try to refreshthe data every time it comes back onlinethese approaches will cause asynchronization request every time ascreen is displayed or we come backonline regardless of whether we need newdata or we think that the centralizeddata may have somehow changed thesesynchronizations require a server calland unless we're careful about thelatency of that network call could endup actually delaying the rendering ofthe screen and hurt the user experiencealso if the size of the informationbeing synchronized is very large thecall may delay the time it takes and maytake quite a while to actually finish sodue to these types of issues we need tothink about the correct synchronizationfrequency for instance it makes sense tosynchronize at the start of a processand when we're online to actually syncinformation to the local storage nowwe'd want to do that because that way wehave all the information we need to beable to work on whatever process may beoccurring it also makes sense tosynchronize at the end of a transactionwhile we're online to synchronize all ofthe data back to the server to make surethe server has all the information aboutthe completed process or transactionthat occurred now it's also important toconsider each sake situation and onlysynchronize the data that we need forthat particular use case so when wethink back to the mobile agent app wemay want to synchronize all of theaccounts summaries at the start of thesession so that we can see the list ofall of those accountsbut then we would only sink and accountin detail when that specific account hasbeen selected so these are some of thegood ideas for frequency and data butthere's also a few more dimensions tosynchronization other things to worryabout regarding synchronization would betransactions and granularity we shouldavoid long synchronizations that occurin a single transaction slow responsesfrom these types of synchronizations canimpact the user experience andpotentially caused an app to seemunresponsive sometimes requests that wemight have expected to be made inparallel may not be able to be made thatway due to multiple apps sharing theresources on the device also longsynchronizations can cause problems ifthey're constantly interrupted by thedevice being offline due to lack ofnetwork connection or the device goinginto standby mode it's also important toensure the correct granularity and orderfor synchronizations when synchronizinginformation from several entities theremay be dependencies among those entitiessuch as synchronizing customerinformation before synchronizing thecontracts which reference thosecustomers these types ofsynchronizations can be very complexbecause there are several entitiesinvolved to help manage those types ofsynchronizations it can help tostructure them and make them incrementalby entity and have partial commits thatway the synchronization is prepared forinterruptions and retry efforts withouthaving to repeat the entiresynchronization from the very start wecan structure synchronizations to handleeach type of entity and sometimes if theinformation is large enough we mighteven want to have the information for asingle entity be broken into chunks sothat if interruptions occur we can kindof deal with those and expect themso in review in this session we talkedabout how mobile applications can uselocal storage to limit the number ofserver-side calls that are going to bemade mobile apps also will need tosynchronize data from the mobile deviceto the server and back we want to beable to control the frequency of thosesynchronizations the size of data in thesynchronizations the number oftransactions and the overall granularityof the data going back and forth thishas a huge impact on the overallperformance of the applications and wealso want to make sure that thosesynchronizations occur in a highlyreliable type of way so that's it forlocal storage and synchronization thanksfor listening