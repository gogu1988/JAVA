Hi there, and welcome to this session onCore Module Patterns.  In this session,we'll start with a quick review of thedifferent elements that we might findinside of core business modules whichwill be in the core layer of the fourlayer architecture then we'll beginlooking at the core business modulepatterns which are patterns that startin the core layer but may involve otherlayers as well so we'll look at the coreentity pattern we'll look at theexternal core into tea service patternsand there are several of these typeswe'll look at the base external coreservice pattern and then there arevariations so we'll look at the localreplica and the synchronizationvariations and we'll look at the directintegration variation and a pub/subvariation and then there are alsovariations not just in the way weapproach it but sort of how we deal withthe different calls that are made sowe'll look at local caching and lazyloading variations as well and then toend we'll look at another importantpattern called the transparency servicepattern so a lot of things to reviewlet's go ahead and get started so as webegin introducing the patterns in thecore business module layer we'll beginto see that there are a number oftypical elements that we find inside ofcore business modules from a UIperspective we would not expect to seescreens or screen flows in a core modulebut we would expect to see web blocksthat might be available to consumers forexample if we wanted to expose a webblock that contained a summary of aproduct it could include an image adescription and the price and wouldprovide a standardized way of reusingthat whole summary from a logicperspective we would expect to be ableto find all the necessary changeoperations for our core entities as wellas other requirements like audit trailsor integration logic so the operationsthat are made available to consumerscould hide any of the side effects orextra logic that would be included froma data perspectivewe would expect to have core entitiesrepresenting our core business conceptsthese entities should be exposed in aread-only fashion to ensure that thecore module is properly abstracting allof the change operations that need to bemade available this prevents consumersfrom performing transformations on thedata in some sort of uncontrolled way wealso may have a need for asynchronousdata processing this may include datasynchronization or any type of digestinformation that might needclassifications or counts of that datathe idea here is to have the core moduleabstract the way the data is handled sothe relevant data is availableimmediately to the consumer and theydon't have to know as many of thedetails asynchronous programming insideof out systems is either done withprocesses or timers so there are acouple choices as to how we wouldapproach that finally a core module canalso expose different types of rolesthese roles may be different than othertypes of roles that could be shared frommaybe a library service those might becompany-wide types of roles in thisparticular case for the core modulesthey may be specific to some sort offeature that's implemented in the moduleso if we have a module that's focused onproducts we might have a role likeproduct administrator who would be ableto edit the details of that product andthen that could be used inside of ourlogic and inside of our web blocks to goahead and restrict access to certaintypes of functionality so now that we'veseen the types of elements that weexpect to find inside of the coremodules let's look at some of the commonpatterns in more detail the most commonpattern for a core module is the coreentity pattern it would expose entitiesaround the core concepts like product orproduct family it would also expose allthe logic to perform updates on thoseentities and any web blocks that mightprovide reusable UI components toshow the data about those entities acore entity should be reusable by one ormore applications if we had a recallprocess a supplier audit and a storeaudit process all of them would need toknow information about products so if wehad a product services core entity itcould be exposed as a read-only entityand we could create a set of actions inlogic that would become the API tocentralize exactly how that entity wouldbe created and updated this pattern isfairly simple and straightforwardbecause our core service is the systemof record and is storing the data inentities inside of out systems let'slook at another key variation of thiscore entity pattern so if we think of anexample where the system of record is indoubt systems itself but might be anexternal ERP system and we wouldimplement an integration service in thelibrary layer to abstract the externalsystem and get the data into our coreservice module in this case there's noentity storing the data in the coreservice the core service is justproviding an API that makes the remotecall to the external system whenever thedata is needed this is what we call anexternal core entity or the externalcore service pattern often we refer tothis pattern as the ECS pattern becausein this case our core entity although ithas the capabilities and the look of aregular core entity the information iscoming from an external system somethingthat's important is that thisintegration service in the library layerthat API must support all the use casesthat the external core service is goingto be able to support so that can bevery important this is such a keyservice that there are actually manyvariations of this service in thisparticular case we're seeing an examplewhere the external system is still thesystem of record and we're notkeeping any data at all this approachcan actually impact the external systemif we're making a large number of callsit can also have performanceimplications due to the latency of thecall through the integration service tothe external system and the fact thatevery call needs to go through both setsof systems and then return to actuallyget the information back the dataretrieval may not actually be optimizedas well so there are some drawbacks tothis and we need to think about how wewould be able to get information fromthe external system in a little bit moredetail the external core service has twomain variations that can help us withthe location of the data one is having alocal replica and another is doingsynchronization so if we go ahead andlist the external core service patternhere as a reference then we can go aheadand look at different variations of thispattern the first variation can be animprovement over the base patternbecause we're going to use a localreplica of the external core systemsdata in this pattern we'll provide localentities to this core service to cachethe information from the externalservice this will end up looking exactlylike the core entity pattern becausewe'll now have some public entities thatwould allow consumers to retrieve thedata this pattern should also have somesort of asynchronous processes toretrieve data from the external systemsand store it in the entity that isserving as the local cache now someadvantages of this approach include theability of this entity to retrieve dataand also use things like scaffolding andother accelerators inside of out systemsalso this integration API can be muchsimpler because we don't need all usecases to go to the enterprise resourceplanning system the external system weonly have to have an API that allows usto get all of the updates that need thatare needed sincelast synchronization has occurred anytype of composition or filtering of datathat might be needed by the consumer canactually be performed using the localcache of course this approach also endsup having a smaller impact on theexternal system since we don't need tomake as many requests to get the datathe second variation is very similar tothe first with the main difference beingthat we're going to isolate thesynchronization logic into its ownmodule having a synchronization moduleas a pattern that we promote not onlybecause the consumers of the coreservice don't need to consume thesynchronization logic but also we wishto have code independence which allowsus to update either of these sets ofcodes independently this would allow usto update the synchronization logicwithout impacting the consumers of thecore service and the synchronizationlogic may be orchestrating thesynchronization of several core servicesin which synchronization order isimportant because sometimes when we'resynchronizing data from an externalservice we may not be able tosynchronize all the data because it'stoo much data so if we only need asubset of the data then thesynchronization module can use theintegration service to get theinformation it needs from the externalservice and then it can use the coreservice to go ahead and update theinformation in the local cache thatsynchronization sequence sort of impliesthat we no longer need the referencefrom the core service to the integrationservice but we still will have thisdirect reference because whenever aconsumer wishes to perform updates weshould first perform the update throughthe integration service on the externalsystem and then once we know the updatewas successful we can update the localcache as well the external system isstill the system of record and we tryhard to avoid two-way synchronizationwhenever possible because that can be alot more complicated and this means thatthe updates are being done synchronouslywhile thelarger synchronizations are really beingdone asynchronously it also means thatwe may need to deal with the occasionwhere someone updates the externalsystem and it didn't originally comefrom our core service or any of theother pieces of this architectureanother variation of the external coreservice pattern is one of directintegration instead of using asynchronization process to retrieve dataat certain times we may want to be ableto immediately react to any change onthe external system in this case we needto provide some sort of API to theexternal system so it can notify us whena change occurs then we can use thenormal path to go ahead and get thechanges from the external system this isbasically a kind of subscriptionmechanism this type of pattern leads usto our final ECS variation whichintroduces an Enterprise Service bus oran ESB if there's an ESB which isproviding publish and subscriptionservices and we can adapt the previouspattern to have the core serviceactually publish to the bus and theexternal system to be able to observefor that information from the bus we canalso have the external Service publishother changes to the bus which wouldthen be subscribed to by the coreservices API when we're getting datafrom an external system sometimesthere's too much information eitherbecause we don't have all the attributesof a particular entity or because wedon't need all the records of aparticular type of data so there arevariations of these patterns that canhelp us regulate the amount of data andnot just the timing at which we get itlet's take a look at some of those sothe first is the summary cache only wewould cache only the summary data thatis frequently listed joined or searchedso the full details for a single entrywill be fetched directly wheneverthey're needed but the summary data willactually be kept in the cache so we wantto use this again when the wholedatabase or whole set of entities is toolarge or too costly to synchronize andthe details are only required for singleentries so we'd actually see the listselect one and then be able to get thatwhich should be a fairly small call thatcould happen very quickly with the listactually inside the cache the list canconstantly be refreshed quickly andwe'll be able to see that in the userinterface there's also the lady lazyloading variation where we try to fetchthe data from the local cache entity ifit's not there then we go and get thesingle entry from the external system wethen cache that record which issometimes referred to as read-throughcaching this can be very useful whenagain the whole database is too big ortoo costly to synchronize and ourintegrations are only going to get smallsections of the database we do want toavoid this though when we need access toa list and we need that information upfront the final pattern that we'd liketo discuss is the transparency servicepattern the transparency service patterntypically provides information that maybe coming from various external systemsfor example we may have all of ourenterprise customers in the first ERPall of our medium-sized customers in oursecond ERP and many of our smallcustomers in our SAS system in this casethe integration service will decidewhich driver to use depending on thetype of customer that is encounteredeach driver exposes the exact same APIbut they integrate with their specificexternal system the core service canthen use the integration service andsynchronize or cache the data asnecessary we can also simplify thistransparency service when we don't needto perform updates from the core servicein that case the integration serviceisn't even necessary because thedecision for where to retrieve the datacouldbe handled by the synchronization or thecore service itself so if we take a lookat that and draw it out we could see aone-way transparency service that issimplified where the integration serviceis gone we decide that thesynchronization synchronization servicewill talk to the drivers and decide howto retrieve the information and thenconsumers can get the information theyneed from the local cache and in thiscase there won't be any updates comingthrough the system to these ERPs becausewe're just reading information so it'simportant to see these types ofillustrations because for any of thepatterns that we've talked about or anyof the variations we can make minormodifications to these patterns to dealwith the instances of given scenarios aslong as we keep the correct level ofabstraction we are trying to reduce theimpact of the different life cycles onthe individual modules and code that arethere if we can manage that complexitythen we can always modify the patternsto fit the situation as best we can soas a quick review we went over theelements in the core business modulesand then we looked at some of thetypical patterns we looked at the coreentity pattern and then what happenswhen that core entity pattern becomes anexternal core entity and then we get theexternal core service patterns we lookedat the base pattern when we have localreplicas and how to do synchronizationas well as how to do direct integrationand pub/sub then we looked at largeinformation scenarios where we could doa local cache or we could do lazyloading and we ended up by talking aboutthe transparency service pattern so wecovered an awful lot of complicatedinformation in this session so hopefullyyou enjoyed the core business patternsthank you for listening