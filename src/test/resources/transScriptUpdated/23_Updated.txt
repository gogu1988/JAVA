Hi there, and welcome to this session onRefactoring an Application.  Whilebuilding applications or solutions wecan use the Four-Layer Canvas follow thearchitecture design process andimplement some of the common patterns totry to create sound architectures butwhat happens when we have to modify ourcurrent applications and architecture todeal with new requirements or newapplications that will help the businessgrow or what happens when we'represented with applications that aren'tfollowing the principles and the bestpractices we may need to refactor thoseapplications to create a soundarchitecture so in this session we'regoing to discuss the prioritizationcriteria for fixing violations that wefind so that we can refactor ourapplications in the best possible orderwe'll also look at ways to promote loosecoupling which will give us a coupledifferent choices to deal with certainsticky situations but will allow us torefactor things and give us a number ofchoiceswe often can solve refactoring problemsby moving elements in between modules sowe'll discuss how that's possible andthen sometimes we have difficultsituations where we need to extractelements from a module and not impactconsumers that had already beenconsuming those elements so there are anumber of different things that we needto focus on we're going to actuallyleave this last one for a differentsession because there are a lot ofdetails but we'll do a quick overviewhere to keep all of the refactoringinformation in one place so here aresome prioritization criteria that can behelpful to determine the order in whichwe should approach refactoring oneimportant thing to remember here is thatevery time we do a refactor we shouldonly be doing the refactoring and notincluding any new development it'simportant to take refactoring changes toproduction before adding any newelements now we should fix violations inthe order in which the fixes will havethemmost impact so at the top of the list weshould fix and remove any upper and sideviolations in the orchestration layer weshould never consume any elements fromthe top of the hierarchy otherwise weend up creating a cluster ofinterconnected modules and then we endup having to bring the whole clusteralong the second criteria is to solvethe same type of violations but for theend user layer this solves the sameproblem but as slightly less of animpact because it's a layer below theorchestration layer third we need to fixany direct cycles between modules in thecore layer this also has slightly lessimpact because it limits clusters tojust the core and the library layersthen we should solve any violations tothe core layer this only requires fixinglibrary modules that aren't properlybeing isolated from the core modulesthis can unexpectedly create littleclusters of core and library modulesalong the way and finally we would needto solve direct cycles between librariesthe impact here is usually limited dueto the fact that these are at the bottomlayer of the hierarchy and they don'taffect many other things so theprioritization criteria give us a niceway of choosing which of the differenttypes of violations that we shouldaddress first and the ones at the top ofthe list are the most important but whathappens if we get to a particular leveland we find multiple violations in oneof these categories well when that isthe case inside a particular categorypick the module with the most consumersfirst as that will actually solve themost amount of conflicts if we happen tobe using the discovery tool to supportthis refactoring then we'll be able tosee the number of consumers and sort themodules by the amount of impact thatthey will haveso if we've selected a violation to workon through the prioritization criteriathen we typically have to do one ofseveral things to fix the violation wemight need to move elements betweenmodules we might need to extract thingsfrom modules or we may actually need tolook at the patterns that are currentlybeing implemented and find better typesof patterns in one particular case agood way to do that is to promote moreloosely coupled patterns so if we'regoing to promote loose coupling what aresome of the areas that it's easiest todo that in one way to keep modulesloosely coupled is to avoid screendestinations we should avoid usingscreen destinations that would causeupward references like an a menu webblock that's in a library module whichmight reference a screen in an end-usermodule screen destinations can alsocause side references when they're usedin between and user modules if we usethem to control screen flow betweenthese modules in this situation useexternal URLs instead and then this willallow for the navigation to occurwithout creating references that causethese types of violations anothertypical example might be when we need toreact to business events and this wouldbe changes to one core business entityaffecting some other core entity so forexample we may have contracts that arerelated to customers as we might expectthe contract core service would consumethe customer core service but what mighthappen when certain attributes of thecustomer change that might affect itsclassification and if thatclassification affects certainconditions of the contract a naturalapproach might be to think that we willcall contract update whenever somethinghappens on the customer and the customerneeds to be updatedwell unfortunately this creates a cycleand conceptually we wouldn't necessarilyexpect a customer to have to depend on acontract there are probably manyconsumers that are interested in thecustomer concept but don't need anyinformation about contracts at all so wewould want to avoid this type ofcircular reference the recommendedsolution is to add a business logicmodule on top of the base core servicesand by composition we'll be able toperform the entire transaction so firstwe would update the customer and then ifnecessary we would update the contractin this situation it's possible to solvethe problem by merging all of theconcepts together but this actuallycreates a much larger module thattightly couples core concepts thatreally have their own life cycles sosometimes you have these types ofproblems and refactoring of this sortreally isn't possible so there are alsosome other alternatives and solutions tothink about so two of those services tothose solutions are either usingservices or using BPT so the firstalternative says let's use rest or asoap web service to avoid the unwantedreference so the contract still does theexpected consumption of customer butcustomer now calls some restful serviceor some soap web service on the contractso this does remove the conceptualdependency the actual dependency but theconceptual dependency persists and welose all the benefits of true changewhich can be a problem anotheralternative is to use light bpt topublish and subscribe events now thiscan be accomplished by simply adding acontrol entity that exposes BPT eventswhere we where when we insert a recordinto the customer ID that was updatedthen we can have the current consumer ofthat customreacting to that in certian now althoughthis solves the problem there's a minordisadvantage to this approach which isthat the updates occur in differenttransactions once the customer isupdated then the contract sees it andreacts as part of a separate transactionin certain cases that can cause aproblem and in other cases it's not thatbig of a dealsometimes the refactoring isn't going tobe quite that complicated we just wishto move some elements from one module toanother to eliminate an upward referenceor a circular reference so in generalwhen we go to move elements from onemodule to another there can be somechallenges one such challenge would bemoving an entity from one module toanother because what's actuallyhappening is we're cutting or removingthe entity from one module and pastingor creating it in another module thatactually creates a new table in thedatabase which is now empty so thequestion becomes how can we moveelements between modules without losingtheir data or their configurationinformation to do this we need to createsome sort of migration script we cancreate migration scripts by using therefactor component that can bedownloaded from the out systems forgethe refactor component is actually atemplate of a migration script so all wehave to do is download it from the forgeand then clone it to create our ownmigration script cloning it preventscollisions and allows multiple people tobe doing a refactoring of differentcomponents at the same time so what canthe refactoring component be used for ifwe use the refactoring component forentities we can move entities from onemodule to another and have the data stayconnected under the covers what isactually happening is that the newentity that is created gets connected tothe old physical table moving roles withrefactor preserves the grants that werealready provided to users in thatparticular environment and the samegeneral thing happens with sitepropertiesand foreign entities where we keep theeffective values so that we know wherethe data is going to be now other typesof elements that don't have anypersistence things like actions webblocks or screens don't need to bedeclared in a refactor at all becauserefactor works by adding declarations inspecific types of actions so if you wantto find out all of the details aroundthat there are details and instructionson how to use refactor and the templateitself on the forgewhen you run a refactor the UI isactually just online help therefactoring does not occur while you'reworking inside of your environment andbrowser it isn't until the refactormodule is deployed that the changes aregoing to be reconnecting the data andrestoring the consistency so duringdevelopment we can move objectsincrementally because we can keeppublishing refactor and only the newchanges would take effect sometimes weneed to extract elements from a modulewithout impacting the consumers so thisis similar to what we just talked aboutwe're removing elements from one moduleto another but in this particular casesome of those modules are now beingconsumed and when we move them we needto make sure that those references arestill going to remain intact so this isa little bit more complicated andrequires seven different stepsto make sure everything goes well we'llgo ahead and talk about this in the nextsession in detail to make sure that weunderstand and can see all the thingsthat are going on as part of thisprocessso in review we started by talking aboutthe prioritization criteria for fixingviolations this way we know the order inwhich we should do the things that needto be refactored sometimes they werefactoring can be a little bit higherlevel or more complicated and we want todo things like promote loose couplingand follow certain types of patterns sorefactoring isn't always as simple asjust fixing violations sometimes it's intrying to improve our overallarchitecture and some of the patternsthat we're following sometimes it is assimple as just trying to fix theviolations and move elements in betweenmodules and if it's a simple one we canuse the refactor tool to help us movethings around sometimes though we try tomove elements in between modules andthose elements are being consumed andbecause that's a little trickier we needto look at that and focus on that inmore detail so that's it for refactoringan application thanks for listening