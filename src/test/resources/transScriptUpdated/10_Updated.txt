In this lesson, youwill learn why validatingyour application's composition isimportant and the four validationrules that can help with that. As we have seen, our goal is topromote the correct abstractionof reusable services and components,optimize the lifecycle independence,and minimize the impactof changes, which makesvalidating architecture animportant step to prevent and avoid mistakesthat will negatively impact these goals. A typical OutSystems factoryusually consists of multiple applications. Although validating the moduleswithin each application is important,it is not enough to assure that theapplication's composition is correct. Therefore, it is important tovalidate your architecture atapplication level to ensure that it issound and easy to deploy and maintain. For that reason, wealso need to understandthe rules to validate the applicationcomposition in the Architecture Canvas. At this point, you should befamiliar with the rules and recommendationsfor validating modules' architecture. If these concepts arenot clear yet, please watchthe previous video on module validation. Four rules should beapplied at the application level. We'll get to each one indetail during this session. Let's take a look at rule number one. The first rule for a correctapplication composition is to simplyapply the rules andrecommendations for modules we learned earlier. This means you musthave no upward references,&nbsp;no side referencesbetween end-user Modules,&nbsp;and no circular references. If these rules are notcorrectly applied in each application,there is no point in trying tohave a correct application composition. We'll now move on to the second rule. Now, you should apply the same rulesused for Modules to your applications,considering the references between them. Remember: the topmost Moduleinside an application definesthe canvas layer where it belongs. Let's take a look at an example. Imagine that you created a projectthat consists of one end-user application. The app is composedof an end-user module,two core modules,and a foundation module. The app follows all thevalidation rules for modules,so everything seemsperfect and ready to deploy. It makes sense topackage everything togetherinto the sameend-user application, whichwill work just fine for this project. Now, let's add a secondproject with a similar structure. You have created asecond end-user application,and everything is still okay interms of the module's architecture,so it is also ready for deployment. But what happens if, in thecontext of a third project,End-user App Number 2 needs toconsume a functionality from Module Core B?If you only think about modules,no architecture issues are present,and this is a perfectlynormal downward reference. However, in terms ofapplication composition,now you are creating a sidereference across two end-user applications. This situation is undesirablebecause now you can't deploy the firstend-user application without includingthe second one in the deployment plan. It is important to remember thatan end-user application should notprovide services to other applications. In this case, the correctthing to do is isolate thecommon modules that provide theservices that multiple apps will consume. This common core applicationwill support the functionalityneeded to both end-user applications. When you decide to shareservices with other apps,you should always try to isolate thecommon modules in common applications. This strategy will helpwith your project flexibility,since you can workin separate componentswithout impacting all the others. Let's now look at rule three. The third rule states that youshould not mix application ownership. From the ITperspective, owners are responsiblefor the functionality in the modules. Having more than one ownerfor an application resultsin complex deploymentmanagement, since accountability forwhat has been changed becomes unclear. If it is not possible toconcentrate the ownership of an application,consider splitting it in such away that ownership is clearly defined. Finally, let's go overthe fourth and last rule. The fourth rule states thatwe should not mix sponsors. Application sponsorsusually have differentdemands and work at different paces. Let's imagine you have a portalthat allows executing simulations overdifferent insurance Lines of Business. If all the Lines of Businessare under the same application,any change made to one of them cannotbe released independently of the others. Therefore, the slowest onewill dictate the release cycle. By spliting into multiple apps,each Line of Business can determinethe pace of its own deliverables,if its applications are independent. You should try to identify thecomponents and apps that are commonand that need to begoverned together, but isolatethe parts that can be independent. In this example, the end-userapplication called Simulation Portalis common to all Lines of Businessand could belong to a different sponsorsuch as the marketing department. Let's recap all four validationrules for application compositionas discussed in this session. The first rule says to layer themodules correctly and follow the validationrules and recommendations for modules. The second rule states that youshould layer your applications correctly. The third rule states thatyou should not mix owners. Clearly-defined ownership of the appsbeing created is key for accountability. Finally, the fourthrule is: Don’t mix sponsors. Each Line of Businessshould have a separate sponsor,so that one app does notdepend on the release of another. Now that you knowthese rules and concepts,don’t miss the next lesson,where we will present the tools youcan use to validate your architecture. 