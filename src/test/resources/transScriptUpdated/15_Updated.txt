Hi there, and welcome to this session onLibrary Module Patterns.  In this case,when we use the term library, we'rereferring to the library layer of thefour layer canvas so we'll be coveringmost common patterns that are used inthe library layer so we'll start bydoing a quick review of the librarymodule elements and the types ofelements that are key to different typesof patterns then we'll jump into lookingat two key library module patterns theextension pattern and the connectorpattern and then we'll talk a little bitabout how when some of these patternsare being used we have to be carefulabout the granularity of api's that arecreated so let's go ahead and getstarted there are a number of differenttypical elements that we might findinside of library modules from a logicperspective we would find normalizedapi's these would map to the externalsystems and provide information in a waythat's consumable we also may findexception handling in which we'd want toavoid different types of error codes sofor example if we have an integration toa web service of an external systemwhere that system returns some sort ofboolean with an error code we wouldn'twant to propagate the error code to ourconsumers otherwise they have to beaware of the details of the externalsystem and we want to insulate them fromhaving to know those types of details sowe can hide those pieces of informationinside of the library module thatperforms the call we can do the test asto whether it's successful or not andthen throw an exception if necessaryexception handling should be the normalway that these types of things arehandled especially when we use theminside of patterns we could also havelogic inside of a library module thatdeals with single sign-on and differenttypes of session logic that will help usinteract with the external system but itwill hide how that interaction occursfrom the consumers that are planning onusing those api's from a dataperspective we would expect to findstructuresfor inputs and outputs of the types ofcalls that will be made to thosenormalized api's and we also may findnon core entities that aren'tbusiness-relatedthose types of entities might besomething like points on a map or othertypes of information when we'reintegrating with other systems thatdon't have directly to do with thebusiness but are still important fromthe UI level we may probably find UIwidgets we would not find full screensbut we might get standardized componentslike a calendar or an accordion we alsowant to be able to extract and reusethemes layouts and exception flows sothose could be included inside oflibrary modules as well also we may haveroles from a specific domain like acompany's intranet common examples mightbe employee or manager and we wouldinclude these in a library module sothat they can be reused across multipleapplications this can help prevent thecreation of similar roles in multipleapplications that would requireadministration and changes to all ofthose roles when any any time when acommon role might change so these aresome of the typical elements that we'regoing to find in library modules whatare some of the typical types ofpatterns a very common library patternis the extension pattern an extensionthat was generated by integration studiocan be a wrapper to an external codelibrary which might be something like adotnet code library to generate a PDF sohere we can see that our wrapper couldgo ahead and contain the logic theactions and the data that will exposethe code that is inside of the externallibrary this way things inside of theOutSystems environment can use all ofthe things that are coming from theexternal library another type ofextension pattern is a wrapper that willwrap entities from an external databasesowe'll use the integration studio againto inspect the external database andimport the data structures so they canbe used as entities inside of outsystems entities created in this way canbehave like regular out systems entitiesthey will have any of the actions andcan be used inside of aggregates as wellanother important pattern is theconnector pattern the connector patternis a pattern with two modules anextension module that can be used toencapsulate an external API and awrapper module to expose the normalizedAPI to the consumers here we can see theextension module for something like aSalesforce connector and here we can seethe module that will be the wrapper thatwe're going to name as far as a is whichwould be an integration service so wewant to be able to use these two modulestogether and part of being able to dothat would be using the extension toencapsulate the external API so here wecan see that we're actually able to do aSalesforce query which is part of theoriginal API and we have all of theinput and output structures that will goto that particular type of API but wealso want to have the wrapper module forconsumers we want to abstract thedetails of the external system and makeit easier to use and simpler tounderstand so if we need to do somethinglike an account search we don't reallywant to call it a Salesforce query wewant to call it an account search so webegin using naming to match the use caseand the concepts that are important wecan go ahead and handle sessionmanagement so that the interactions withthe external system are hidden but areavailable in a way that's easy tounderstand and then we can alsonormalize business concepts so insteadof having something like a return objectwe'll actually have a an accountstructure and an opportunity structurewhich might be easier for the businessto understandan important consideration for theintegration services of the connectorpattern is to keep the right level ofgranularity of the api's when we'reintegrating with large external systemsfor example we might have a very largesi P system if it had hundreds ofbabbies that might create hundreds ofapi's and structures inside of ourintegration service instead of havingone huge integration service it mightmake sense for us to split this largeintegration into a number of smallerapi's and integrations per functionalarea so we could break this into the SIP financials si pH R and s AP materialsmanagement they would still be talkingto the same external si P system butthis helps balance the granularity andavoid a single bottleneck that mightaffect too many consumers what we meanby that is that this integration servicewould have to be used by anyone whowants access to the large si P systemwe're here by breaking things up peopleusing the finance components versus theHR components would actually be usingdifferent integration services not onlydoes that help avoid potentialbottlenecks but it could also make thesolution easier to maintain consumers ofthe financial api's would not beimpacted by changes or additions to theHR api so to review here we looked atthe library module elements and howthose elements will show up in differenttypes of library module patterns a keypattern that we talked about was theextension pattern in the two differentways the extension pattern can becreated and with yun looked at theconnector pattern and how theintegration services of those connectorpatterns might need to be sensitive tothe granularity of the api's that arecreated so that's it for the librarymodule patterns thanks for listening