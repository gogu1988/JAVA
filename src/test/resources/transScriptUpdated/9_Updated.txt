In this lesson, you willlearn why validating yourarchitecture design is so important. We will explain theArchitecture Canvas validationrules for modules and also presentsome extra recommendations that will helpyou achieve a solid architecture design. Designing yourarchitecture properly willallow you to buildapplications fast, build them right,and build them for the future. From an architecture standpoint. . . Our goal is to promotethe correct abstractionof reusable services and components, Optimize lifecycle independence, and minimize the impact of changes. Therefore, validatingthe architecture of asolution is an important step toprevent and avoid mistakes that will leadto issues like poorservice abstraction,unmanageable dependencies, and slow-moving,inflexible legacy systems. The way we do that with OutSystemsis by using the Architecture Canvas. After designing yourarchitecture and placing the modulesin the correct layers of the canvas,you need to validate what you createdto make sure your architecture is sound. In order to perform this validation,you must follow a set of basic rules. The first rule states that we shouldnot have upward references across layers. In practice, this rule means thata module in a lower layer should notreference a module in a higher layer. An upward referencecan create a cluster,where any two modules directly orindirectly have a circular dependency. The circular dependencycan cause any module thatreferences an element inside thecluster to be dependent on the entire cluster. In this case, byfollowing the red arrows,Core Module 1 can reachCore Module 2 indirectly. Also, Core Module 2 canreach Core Module 1 indirectly. Then, if we have an End-User Module2 consuming elements from CoreModule 2, it may become dependenton other modules inthe cluster as well, eventhough it should not be aware of them. This situation can causeEnd-User Module 2's deployment tohave an unnecessarily large footprint. In addition, changes to anymodule in the cluster will requireEnd-User Module 2 to be updated as well. The second rule statesthat we should not have sidereferences between end-user modules. This rule ensures that themodules are correctly isolated,allowing them to havedifferent lifecycles. In this example, End-User Module 1 isa consumer of another End-user module,thus creating a side reference. This scenario will causeEnd-User 1 to also become dependenton a cluster that shouldn't affect it. If an end-user module needs to reusesomething from another end-user module,then we should analyze whatelements are being referenced and probablypromote those elements to a Core module. However, this rule has anexception.  Screen referencesbetween end-user modules are allowed. This exception is explained inmore detail in our documentationon strong and weak references. Finally, the third rulestates that we should avoid cyclesbetween core or foundation modules. If you follow the first rule, youshould not have circular referencesbetween modules in different layers. Following the second ruleprevents cycles between end-user modules. However, we still need toavoid circular referencesin the core and foundation layers. Cycles are always undesirable,since they bring unexpected impacts. They indicate that theconcepts are not correctlyabstracted and need to be reviewed. These are the three ArchitectureCanvas validation rules for modules. They are simple to understandand memorize and will help preventissues in your architecture design. In addition to these rules, wepresent some extra recommendationsthat are not related to dependenciesbut that can help improve your solution. The firstrecommendation is that core modulesshould not have front-end Screens. Sometimes developers addScreens to run some tests in thecore module on which they are working. Even if these Screens areuseful to support testing,they should be removedfrom the core module andplaced in an end-user testing module. One of the major dangers ofkeeping test Screens on core modulesis that they can open up a securitybreach if they end up in production. A second recommendationis that all your publicEntities should be set to 'read only. 'This setting willensure that you are notallowing consumers todirectly create, update,or delete records in the database. Instead, the consumers can use a coreservice that handles the business rules,such as validations or normalizations. Make sure that youimplement all your businesstransactions as public actions tofully abstract the core module and have asafe service exposed to other consumers. The third recommendation is to not havebusiness logic at the foundation layer. This is a commonmistake, but this layer needsto be business agnostic so that it canbe reused in any domain of application. Similarly, the fourthrecommendation states that we should not havecore Entities in the foundation layer. We must ensure that the foundationlayer has only non-functional requirements. However, that does notmean that a foundation layermodule cannot have Entities at all. If you need to create ageneric service to audit all yourtransactions and createan audit Entity, that isperfectly possible since it is a case ofsupporting a non-functional requirement,not a business-related scenario. So now you know how touse the three ArchitectureCanvas validation rules for modules. In addition to therules, we've offered fourextra recommendations that will helpyou achieve a solid architecture design. In the next lessons,we'll cover the validationrules for apps and which tools canbe used to help the validation process. 